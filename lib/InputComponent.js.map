{"version":3,"sources":["InputComponent.js"],"names":["InputComponent","props","context","value","defaultValue","state","componentDidMount","attachForm","componentWillReceiveProps","nextProps","hasOwnProperty","setState","shouldComponentUpdate","nextState","componentWillUnmount","detachForm","onChange","e","callback","isDisabled","disabled","isReadOnly","readOnly","getValue","getStyleStates","valid","states","invalid","displayName","propTypes","name","string","bool","func","propName","componentName","Error","defaultProps","contextTypes"],"mappings":"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","file":"InputComponent.js","sourcesContent":["/**\n* Copyright 2016 Baidu Inc. All rights reserved.\n*\n* @file InputComponent\n* @author leon <ludafa@outlook.com>\n*/\n\nimport {Component, PropTypes} from 'react';\nimport shallowEqual from './util/shallowEqual';\n\nexport default class InputComponent extends Component {\n\n    constructor(props, context = {}) {\n        super(props, context);\n        const {value, defaultValue} = props;\n        this.state = {\n            value: value === void 0 ? defaultValue : value\n        };\n    }\n\n    /**\n     * 这里主要做一件事，就是注册到 form 上，让 form 在 getData() / validate() 时避免递归遍历\n     */\n    componentDidMount() {\n\n        const attachForm = this.context.attachForm;\n\n        if (attachForm) {\n            attachForm(this);\n        }\n\n    }\n\n    /**\n     * 接收属性处理\n     *\n     * 我们在这里主要是做 value 更新和校验计算\n     *\n     * ### 值更新\n     *\n     * 这个事情把实体控件的的 controlled / uncontrolled 处理解放了\n     * 实体控件只需要做 render 和 事件处理就好了\n     *\n     * @param {Object} nextProps 新属性\n     */\n    componentWillReceiveProps(nextProps) {\n\n        let value = nextProps.value;\n\n        if (\n            nextProps.hasOwnProperty('value')\n            && this.state.value !== value\n        ) {\n            this.setState({value});\n        }\n\n    }\n\n    /**\n     * 是否应当更新组件\n     *\n     * @param {*} nextProps 下一个属性\n     * @param {*} nextState 下一个状态\n     * @return {boolean}\n     */\n    shouldComponentUpdate(nextProps, nextState) {\n        return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);\n    }\n\n    componentWillUnmount() {\n\n        const detachForm = this.context.detachForm;\n\n        if (detachForm) {\n            detachForm(this);\n        }\n\n    }\n\n    /**\n     * 值变化处理函数\n     *\n     * @param {Object}  e         值变化事件\n     * @param {Function} callback 完成更新后回调\n     */\n    onChange(e, callback) {\n\n        const {onChange, value} = this.props;\n\n        onChange && onChange(e);\n\n        // 在 React 中，只要 props 中的 value 是 undefined\n        // 那么 input 就会进入 uncontrolled 模式\n        // 这种对应着 controlled 组件逻辑，\n        // 在 controlled 模式下，我们就不需要将 value 同步到 state 中；\n        // 这个同步的过程是在 componentWillReceiveProps 中处理的；\n        if (value !== void 0) {\n            callback && callback();\n            return;\n        }\n\n        // 这种对应 uncontrolled 逻辑\n        if (e.value !== this.state.value) {\n            this.setState({value: e.value}, callback);\n        }\n\n    }\n\n    isDisabled() {\n        return this.props.disabled;\n    }\n\n    isReadOnly() {\n        return this.props.readOnly;\n    }\n\n    getValue() {\n        return this.state.value;\n    }\n\n    getStyleStates() {\n\n        const {\n            readOnly,\n            valid,\n            disabled\n        } = this.props;\n\n\n        let states = {};\n\n        if (readOnly !== void 0) {\n            states['read-only'] = readOnly;\n        }\n\n        if (disabled !== void 0) {\n            states.disabled = disabled;\n        }\n\n        if (valid !== void 0) {\n            states.valid = !!valid;\n            states.invalid = !valid;\n        }\n\n        return states;\n\n    }\n\n\n}\n\nInputComponent.displayName = 'InputComponent';\n\nInputComponent.propTypes = {\n    name: PropTypes.string,\n    readOnly: PropTypes.bool,\n    valid: PropTypes.bool,\n    onChange: PropTypes.func,\n    value(props, propName, componentName) {\n        if (\n            props.hasOwnProperty(propName)\n            && !props.hasOwnProperty('onChange')\n            && !props.readOnly\n        ) {\n            return new Error(`\\\nFailed form propType: You provided a \\`value\\` prop to a \\\nform field without an \\`onChange\\` handler. This will \\\nrender a read-only field. If the field should be mutable \\\nuse \\`defaultValue\\`. Otherwise, set either \\`onChange\\` or \\\n\\`readOnly\\`. Check the render method of \\`${componentName}\\`.`);\n\n        }\n    },\n    defaultValue(props, propName, componentName) {\n        if (\n            props.hasOwnProperty(propName)\n            && props.hasOwnProperty('value')\n        ) {\n\n            return new Error(`\\\n${componentName} with both value and defaultValue props.\\\nInputComponent must be either controlled or uncontrolled \\\n(specify either the value prop, or the defaultValue prop, but not both).`);\n\n        }\n    }\n};\n\nInputComponent.defaultProps = {};\n\nInputComponent.contextTypes = {\n    attachForm: PropTypes.func,\n    detachForm: PropTypes.func\n};\n"]}