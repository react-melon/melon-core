{"version":3,"sources":["InputComponent.js"],"names":["InputComponent","props","context","value","defaultValue","state","attachForm","nextProps","nextState","hasOwnProperty","setState","detachForm","e","callback","onChange","disabled","readOnly","valid","states","invalid","displayName","propTypes","name","string","bool","func","propName","componentName","Error","defaultProps","contextTypes"],"mappings":"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","file":"InputComponent.js","sourcesContent":["/**\n* Copyright 2016 Baidu Inc. All rights reserved.\n*\n* @file InputComponent\n* @author leon <ludafa@outlook.com>\n*/\n\nimport {Component} from 'react';\nimport PropTypes from 'prop-types';\nimport shallowEqual from './util/shallowEqual';\n\nexport default class InputComponent extends Component {\n\n    constructor(props, context = {}) {\n        super(props, context);\n        const {value, defaultValue} = props;\n        this.state = {\n            value: value === void 0 ? defaultValue : value\n        };\n    }\n\n    /**\n     * 这里主要做一件事，就是注册到 form 上，让 form 在 getData() / validate() 时避免递归遍历\n     */\n    componentDidMount() {\n        const attachForm = this.context.attachForm;\n        if (attachForm) {\n            attachForm(this);\n        }\n    }\n\n    shouldComponentUpdate(nextProps, nextState) {\n        return !shallowEqual(this.state, nextState) || !shallowEqual(this.props, nextProps);\n    }\n\n    /**\n     * 接收属性处理\n     *\n     * 我们在这里主要是做 value 更新和校验计算\n     *\n     * ### 值更新\n     *\n     * 这个事情把实体控件的的 controlled / uncontrolled 处理解放了\n     * 实体控件只需要做 render 和 事件处理就好了\n     *\n     * @param {Object} nextProps 新属性\n     */\n    componentWillReceiveProps(nextProps) {\n\n        let value = nextProps.value;\n\n        if (\n            nextProps.hasOwnProperty('value')\n            && this.state.value !== value\n        ) {\n            this.setState({value});\n        }\n\n    }\n\n    componentWillUnmount() {\n\n        const detachForm = this.context.detachForm;\n\n        if (detachForm) {\n            detachForm(this);\n        }\n\n    }\n\n    /**\n     * 值变化处理函数\n     *\n     * @param {Object}  e         值变化事件\n     * @param {Function} callback 完成更新后回调\n     */\n    onChange(e, callback) {\n\n        const {onChange, value} = this.props;\n\n        onChange && onChange(e);\n\n        // 在 React 中，只要 props 中的 value 是 undefined\n        // 那么 input 就会进入 uncontrolled 模式\n        // 这种对应着 controlled 组件逻辑，\n        // 在 controlled 模式下，我们就不需要将 value 同步到 state 中；\n        // 这个同步的过程是在 componentWillReceiveProps 中处理的；\n        if (value !== void 0) {\n            callback && callback();\n            return;\n        }\n\n        // 这种对应 uncontrolled 逻辑\n        if (e.value !== this.state.value) {\n            this.setState({value: e.value}, callback);\n        }\n\n    }\n\n    isDisabled() {\n        return this.props.disabled;\n    }\n\n    isReadOnly() {\n        return this.props.readOnly;\n    }\n\n    getValue() {\n        return this.state.value;\n    }\n\n    getStyleStates() {\n\n        const {\n            readOnly,\n            valid,\n            disabled\n        } = this.props;\n\n\n        let states = {};\n\n        if (readOnly !== void 0) {\n            states['read-only'] = readOnly;\n        }\n\n        if (disabled !== void 0) {\n            states.disabled = disabled;\n        }\n\n        if (valid !== void 0) {\n            states.valid = !!valid;\n            states.invalid = !valid;\n        }\n\n        return states;\n\n    }\n\n\n}\n\nInputComponent.displayName = 'InputComponent';\n\nInputComponent.propTypes = {\n    name: PropTypes.string,\n    readOnly: PropTypes.bool,\n    valid: PropTypes.bool,\n    onChange: PropTypes.func,\n    value(props, propName, componentName) {\n        if (\n            props.hasOwnProperty(propName)\n            && !props.hasOwnProperty('onChange')\n            && !props.readOnly\n        ) {\n            return new Error(`\\\nFailed form propType: You provided a \\`value\\` prop to a \\\nform field without an \\`onChange\\` handler. This will \\\nrender a read-only field. If the field should be mutable \\\nuse \\`defaultValue\\`. Otherwise, set either \\`onChange\\` or \\\n\\`readOnly\\`. Check the render method of \\`${componentName}\\`.`);\n\n        }\n    },\n    defaultValue(props, propName, componentName) {\n        if (\n            props.hasOwnProperty(propName)\n            && props.hasOwnProperty('value')\n        ) {\n\n            return new Error(`\\\n${componentName} with both value and defaultValue props.\\\nInputComponent must be either controlled or uncontrolled \\\n(specify either the value prop, or the defaultValue prop, but not both).`);\n\n        }\n    }\n};\n\nInputComponent.defaultProps = {};\n\nInputComponent.contextTypes = {\n    attachForm: PropTypes.func,\n    detachForm: PropTypes.func\n};\n"]}